#pragma kernel CSMain

#include "Packages/nyc.scatter.depthkit.core/Runtime/Resources/Shaders/Includes/Utils.cginc"

Texture2DArray<float> _InputTexture;
SamplerState _InputTrilinearClampSampler;

globallycoherent RWTexture2DArray<float> _OutputTexture;
float2 _Axis;
float _MinDim;  // The minimum pixel dimensions of the (unpadded) texture size
StructuredBuffer<float> _BlurWidth; // normalized multiple of minimum dimension

static const uint BLUR_SAMPLE_RADIUS = 6;
static const uint BLUR_SAMPLE_WIDTH = BLUR_SAMPLE_RADIUS * 2 + 1;

static const uint3 WorkGroupSize = uint3(8, 8, 1);

[numthreads(WorkGroupSize.x, WorkGroupSize.y, WorkGroupSize.z)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 GroupId : SV_GroupID, uint3 GroupThreadId : SV_GroupThreadID, uint GroupIndex : SV_GroupIndex)
{
    uint3 inputSize;
    _InputTexture.GetDimensions(inputSize.x, inputSize.y, inputSize.z);
    uint3 outputSize;
    _OutputTexture.GetDimensions(outputSize.x, outputSize.y, outputSize.z);

    if (!inBounds(id, outputSize)) { return; }

    float blurWidth = _BlurWidth[id.z];

    float lod = (max(0.0, log2(blurWidth * _MinDim / float(BLUR_SAMPLE_RADIUS))));
    float2 oneOverImageDimensions = float2(1.0f, 1.0f) / float2(inputSize.xy);
    float2  accumulator = float2(0.0f, 0.0f), uv;
    float r = float(BLUR_SAMPLE_WIDTH - 1) / 2.f, kr, weight, interp;
    for (uint k = 0; k < BLUR_SAMPLE_WIDTH; k++)
    {
        kr = float(k) / r - 1.0f;
        weight = exp(-2.0f * kr * kr);

        interp = blurWidth * kr;

        uv = (float2(id.xy) + 0.5f) / _MinDim;
        uv = (uv + interp * _Axis) * _MinDim * oneOverImageDimensions;

        float s = _InputTexture.SampleLevel(_InputTrilinearClampSampler, float3(uv, id.z), lod);

        accumulator += float2(s * weight, weight);
    }
    float blurred = accumulator.x / accumulator.y;

    _OutputTexture[int3(id.xyz)] = blurred;
}
